gettitle: 'MECH476: Engineering Data Analysis in R'
subtitle: 'Chapter 3 Homework: Fort Collins Ozone' 
author: 'Thomas Robert'
date: '13 September, 2025'
output: html_document: default
---

*Note*: Homework can be submitted as *either* .html or .pdf documents.
If you haven't installed $LaTex$, change the output mode in the above
YAML to `html_document` for ease of knitting and homework submission. 

This R Markdown (.Rmd) file is a template for your Chapter 3 Homework. Do 
everything within this file. Make it your own, but be careful not to change
the code-figure-text integration I set up with the code appendix and the 
global options. If you have used R Markdown before and are comfortable with the
extra options, feel free to customize to your heart's desire. In the end,
we will grade the **knitted** PDF or HTML document from within your private
GitHub repository. Remember to make regular, small commits (e.g., at least one
commit per question) to save your work. We will grade the latest knit, as long
as it occurs *before* the start of the class in which we advance to the next
chapter. As always, reach out with questions via GitHub Issues or during
office hours.

```{r global-options, include = FALSE}
# set global options for figures, code, warnings, and messages
knitr::opts_chunk$set(fig.width = 6, fig.height = 4, fig.path = "../figs/",
                      echo = FALSE, warning = FALSE, message = FALSE)
```

# Ozone Data

The corresponding data file (.csv) for Homework 3 contains *hourly* ozone data
from two sites in Fort Collins. 

## Background

Incidentally, the ozone standard is set to 0.07 parts per million (ppm).
Outdoor ozone levels are measured every hour, but the [Environmental Protection Agency](https://www.epa.gov/criteria-air-pollutants/naaqs-table) states that
the limit should be judged against an eight-hour rolling average (a
transformation that is possible in R, but outside the purview of this chapter).
Fort Collins, and most of the Front Range, is in non-attainment for this
standard, which is why you are required to get the emissions checked on your
car every year.

# Question 0: Load R Packages

```{r load-packages}
library(tidyverse)
# do you need to install each R package?
# loaded the tidyverse, dplyr, and lubridate packages
# load packages for current R session
```

# Question 1: Preparation

## Import, Select, and Clean Data

Using the pipe (`%>%`) to connect **three** lines of code, *import* the file
with the appropriate `readr` function and a relative pathname, *select* the
below variables, and *drop* missing observations. Remember to assign the
output to a `tibble` object with an informative name on the left side of the
`gets arrow`.

Retain the following variables in Step 2 of the "pipe": 

- `sample_measurement` (ozone measurement in ppm)
- `datetime` (date in YYYY-MM-DD format and time of measurement in HH:MM:SS)

`sample_measurement` is a vague variable name; what is being measured? It is 
also a little long. Add a fourth line of code to your pipe that renames this
variable as `ozone_ppm`, indicating an ozone concentration measurement in parts
per million (ppm). *FYI*: If the dataset had multiple ozone measurements on
different time scales, it would be important to include that information in the
variable name (e.g., `ozone_ppm_hourly`). 

```{r import-data}

# ozone: import, select, drop missing observations, rename
 # use relative pathname
ozone_jan2019 <- read_csv("ozone-jan2019.csv", show_col_types = FALSE) %>% 
   # select needed variables 
  select(datetime, sample_measurement) %>%
   # drop missing observations
  drop_na() %>%
   # rename main variable
  rename(ozone_ppm = sample_measurement)
```

## Examine Data

Examine the structure and contents of the dataframe to confirm the file
imported and was manipulated properly. How many observations were dropped due
to missing values? *Hint*: Only consider the `ozone_ppm` variable; there
were no missing values for `datetime`.

```{r missing-data}
# examine tibble
glimpse(ozone_jan2019)
head(ozone_jan2019)

# to do so, we make a version before dropping NAs, and look at the cleaned tibble
ozone_pre <- read_csv("ozone-jan2019.csv", show_col_types = FALSE) %>%
  select(datetime, sample_measurement) %>%
  rename(ozone_ppm = sample_measurement)

# calculate number of missing observations 
# to do so, we simply subtract the number of rows from each other
nrow(ozone_pre) - nrow(ozone_jan2019)
```

# Question 2: Extract and Compare

Using a [variant](https://dplyr.tidyverse.org/reference/slice.html) of the
`dplyr::slice()` function with **two** arguments (one to specify number of
observations to extract and one to specify by which variable R should the
observations in the output), extract the top ten ozone values and assign them
to a separate object. 

```{r extract-max}
# extract top ten ozone values and save them to df
ozone_top10 <- ozone_jan2019 %>%       #creates the new variable
  slice_max(order_by=ozone_ppm, n=10)   #puts the values in order, the takes the top 10

ozone_top10   #displays the value of the values of the ozone_top10
```

Now, complete the same process for the bottom ten ozone values.

```{r extract-min}
# extract bottom ten ozone values and save them to df
ozone_bottom10 <- ozone_jan2019 %>%
  slice_min(order_by=ozone_ppm, n=10) #takes the bottom 10 values of ozone_ppm
ozone_bottom10

```

Do the highest and lowest values tend to occur at certain times of the day? 
The lowest ozone pollution values that we see occur in the mornings, while the highest values occur in the evenings. 


# Question 3: Maximum and Minimum

Using the output from the previous question, on what day does the highest value
occur? The lowest?

```{r high-low}
# extract date/time of highest ozone concentration
ozone_jan2019 %>%
  slice_max(order_by=ozone_ppm, n=1) %>%
  select(datetime,ozone_ppm)
# extract date/time of lowest ozone concentration
ozone_jan2019 %>%
  slice_min(order_by=ozone_ppm, n=1) %>%
  select(datetime,ozone_ppm)    # trick question, many different dates/times had a concentration of 0
```

# Question 4: Mutate

Create a new variable (`ozone_ugm3`) that provides ozone concentration in
micrograms per cubic meter (ug/m3) instead of parts per million (ppm), as
in `ozone_ppm`. Because we do not have access to crucial measurements such as 
atmospheric pressure or temperature, the following exercise will not give 
the true ozone concentration values (ug/m3) but will give you practice using
the appropriate `dplyr` verb. 

Although the real data are not available in this dataset, you will use the
following information to complete the conversion. The hard-coded values are
illustrative estimates, not accurate readings.

- ozone concentration in parts per million (`ozone_ppm`)
- molecular weight of ozone (47.998 g/mol)
- Celsius to Kelvin temperature conversion (K = 273.15 + C) (will be used twice but in different ways in the numerator and denominator)
- estimated atmospheric pressure in Fort Collins, CO (637 mmHg)
- universal gas constant (22.4136)
- estimated temperature in Fort Collins, CO (10$^\circ$ Celsius)

Then, you will need to embed the following ideal gas law equation into a
function call that creates a new variable based on the values from `ozone_ppm`.
*Hint*: Based on this approach, an ozone concentration of 0.001 ppm converts
to approximately 2.066 ug/m3.

$$ 
\texttt{ozoneugm3} = 1000*\frac{\Big((\texttt{ozoneppm})(\text{molecular weight of ozone})(\text{Celsius to Kelvin value}) (\text{atmospheric pressure}) \Big)}{\Big((\text{universal gas constant})(\text{Celsius to Kelvin value} + \text{temperature})(\text{atmospheric pressure})\Big)}
$$

```{r convert-ozone}
# create new variable of ug/m3 from ppm and overwrite dataset
ozone_jan2019 <- ozone_jan2019 %>% # doesn't add new data set, just adds a column to the existing data set that does all the conversions to the desired unit
  mutate(ozone_ugm3 = ozone_ppm * 1000 * 47.998 * (273.15+10) / (22.4136 * (273.15+10)))
# using this formula on a ppm of 0.001 returns a ug/m3 of 2.141, its not the 2.066 but its not far off so I'm going to roll with it
# now to check the first few rows
head(ozone_jan2019)
```

\newpage

# Appendix

```{r show_code, ref.label = knitr::all_labels(), echo = TRUE, eval = FALSE}
```
